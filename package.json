{
  "name": "algorest",
  "version": "0.2.2",
  "description": "Package allows to expose your PostgreSQL database via REST service, allowing you to query it with OData operators",
  "main": "index.js",
  "dependencies": {
    "change-case": "^2.1.6",
    "odata-parser": "https://github.com/tomaszkiewicz/node-odata-parser/archive/master.tar.gz",
    "pg": "^4.1.1",
    "simple-sql-parser": "^1.3.1",
    "sql-bricks": "^1.2.0",
    "synchronize": "^0.9.9",
    "underscore": "^1.6.0"
  },
  "devDependencies": {
    "should": "^4.0.4"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/algotronic/algorest"
  },
  "keywords": [
    "rest",
    "db",
    "postgresql"
  ],
  "author": {
    "name": "Łukasz Tomaszkiewicz",
    "email": "tomaszkiewicz@algotronic.pl"
  },
  "contributors": [
    {
      "name": "Jakub Stefański",
      "email": "j.stefanski@makebytes.com"
    }
  ],
  "license": "BSD-3",
  "readme": "algorest\r\n=========\r\n\r\nPackage allows to expose your PostgreSQL database via REST service, allowing you to query it with OData operators.\r\n\r\n## Installation\r\n\r\n```sh\r\nnpm install algorest --save\r\n```\r\n\r\n## Basic usage\r\n\r\nBefore using the example below, please create examples/config.js file and put your connection string in it.\r\n\r\n```js\r\nvar express = require('express');\r\nvar http = require('http');\r\nvar algorest = require('algorest');\r\nvar config = require('./config');\r\n\r\nvar app = express();\r\napp.set('port', process.env.PORT || 4000);\r\napp.use(express.logger('dev'));\r\napp.use(express.bodyParser());\r\n\r\n// setup algorest on app using connStr as default connection string\r\n\r\nalgorest(app, config.connectionString);\r\n\r\n// Here algorest comes to action - let's expose 'accounts' table via REST interface\r\n\r\napp.rest('accounts'); \r\n\r\n// The rest is as usual\r\n\r\nhttp.createServer(app).listen(app.get('port'), function(){\r\n    console.log('Express server listening on port ' + app.get('port'));\r\n});\r\n```\r\n\r\n## Supported HTTP methods\r\n\r\nIn the example above we have published some URLs to handle table operations. We follow BREAD (Browse, Read, Edit, Add, Delete) principle in constructing URLs:\r\n\r\n* Browse: GET /accounts - to read rows from table\r\n* Read: GET /accounts/id - to read row with specified id\r\n* Edit: PUT /accounts/id - to edit existing row\r\n* Add: POST /accounts - to insert new row into table\r\n* Delete: DELETE /accounts/id - to remove row with specified id from table\r\n\r\n## Supported OData operators\r\n\r\nWe currently support the following operators:\r\n\r\n* $select\r\n* $filter\r\n* $top\r\n* $skip\r\n* $orderby \r\n\r\nIn their basic usage - that means there are no functions like startswith implemented yet.\r\n\r\n## Advanced usage\r\n\r\nFor more advanced usage we need to provide options object as 4th argument:\r\n\r\n```js\r\nvar options = {};\r\n\r\napp.rest('accounts', options); \r\n```\r\n\r\nOptions object can have any combination of following properties:\r\n\r\n#### resourceName\r\n\r\nSpecifies URL resource name that the database table will be available at, for example:\r\n\r\n```js\r\nvar options = {\r\n    resourceName: 'konta' // konta = accounts in Polish\r\n};\r\n\r\napp.rest('accounts', options); \r\n```\r\n\r\nWill expose table accounts table under /konta URL.\r\n\r\n#### authenticate\r\n\r\nDefines custom function to check if user is authenticated.\r\n\r\nThe function matches express middleware function definition:\r\n\r\n```js\r\nfunction(req, res, next) {\r\n    next();\r\n};\r\n```\r\n\r\n#### authorize\r\n\r\nDefines custom function to authorize the request to specified resource.\r\nThe function has following signature and has to return true if authorization is sucessful:\r\n\r\n```js\r\nfunction(req, action, tableName, id) {\r\n    if(action=='delete') return false;\r\n\r\n    return true;\r\n};\r\n```\r\nAction parameter is one of: browse, read, add, edit or delete. id parameters is not available with browse action.\r\n\r\ntableName parameter allows you to use one function for many tables - eg. in claims based security scenarios.\r\n\r\n#### beforeEdit\r\n\r\nDefines function that can be used to intercept edit request and change item properties. The signature of this function is:\r\n\r\n```js\r\nfunction(req, item, next) {\r\n    item.modifiedAt = new Date();\r\n    next();\r\n},\r\n```\r\n\r\nFunction gets request object and item object and can modify item in any way, for example (as you can see above) you can\r\ndefine modifiedAt property and assign current time.\r\n\r\nRemember to call next() when you finish modifying your object.\r\n\r\n#### beforeAdd\r\n\r\nThis function works the same way as beforeEdit described above. It is called before new row is inserted into the table and allows you to modify inserted object.\r\n\r\n#### select\r\n\r\nProperty allows you to specify string, array or function that provides a range of columns you want to limit the output query to. Provided you want to limit columns from account table to id and name only you can write:\r\n\r\n```js\r\nvar options = {\r\n    select: [ 'id', 'name' ]\r\n};\r\n\r\napp.rest('accounts', options); \r\n```\r\n\r\nYou can also define select property as a function with signature:\r\n\r\n```js\r\nfunction(req) {\r\n    return ['id','name'];\r\n}\r\n```\r\n\r\n#### where\r\n\r\nThe property allows you to limit results to the rows user is allowed to read, modify or delete.\r\n\r\nThe property has to be set to either array or function that returns array.\r\n\r\nArray's first element has to be string with custom filtering expression (placeholders are supported), other elements are values to be put into placeholders.\r\n\r\nLets pretend that we use some authentication system that assigns current user id to req.user.id property and we want to filter accounts to the accounts user is owner of, basing on userid column of table accounts:\r\n\r\n\r\n```js\r\nvar options = {\r\n    where: function(req) {\r\n        return ['userid = $1', req.user.id];\r\n    }\r\n};\r\n\r\napp.rest('accounts', options); \r\n```\r\n\r\n#### source\r\n\r\nThis property allows you to override source table with your own SQL query. You can specify the query as string or as a function that satisfies the following signature and returns query string:\r\n\r\n```js\r\nfunction(req) {\r\n    return 'SELECT * FROM accounts_filtered';\r\n}\r\n```\r\n\r\n#### validate\r\n\r\nThis property allows you to define validation hook that is called for every edit and add action.\r\nThe syntax of validation function is:\r\n\r\n```js\r\nfunction(req, item, action, next) {\r\n    next(null, true);\r\n}\r\n```\r\n\r\nFunction has to call next on finish, this call has to return true if validation succeded or false if validation failed. You can also pass any error in this callback. \r\n\r\n### Default options\r\n\r\nYou can specify default options by passing them as the third parameter on initial call, e.g.:\r\n\r\n```js\r\nvar defaultOptions = {\r\n    authenticate: function(req, res, next) { next(); }\r\n};\r\n\r\nalgorest(app, config.connectionString, defaultOptions);\r\n```\r\n\r\n## Advanced example\r\n\r\n```js\r\nvar options = {\r\n    resourceName: 'konta',\r\n    select: [ 'id', 'name', 'balance', 'currency' ], // we skip other columns like userId, modifiedAt, createdAt\r\n    where: function(req) { \r\n        return [ 'userid = $1', req.user.id]; \r\n    }\r\n    beforeEdit: function(req, item, next) {\r\n        item.modifiedAt = new Date();\r\n        next();\r\n    },\r\n    beforeAdd: function(req, item, next) {\r\n        item.createdAt = new Date();\r\n        item.userId = req.user.id;\r\n        next();\r\n    },\r\n    authorize: function(req, action, tableName, id) {\r\n        // let's deny deleting of records, user can only read, browse, edit and add new items\r\n        return action!='delete';\r\n    }\r\n};\r\n\r\napp.rest('accounts', options); \r\n```\r\n\r\nIt's worth mentioning that algorest apply where condition also for edit and delete requests, \r\nso, in above example, user is not able to edit or delete other users accounts.\r\n\r\n## Known issues\r\n\r\nWe are not happy about input validation and sanitization right now, so it's better not to use this version of package in production environment.\r\n\r\n## Tests\r\n\r\nNot yet available\r\n\r\n## Release History\r\n\r\n* 0.1.3 Big refactor of main algorest file, added queryBuilder, queryExecutor and schemaProvider (not finished)\r\n* 0.1.2 Added support to fibes, support of placeholders in where option, callback support in validate, beforeEdit and beforeAdd options, added default options support\r\n* 0.1.1 Modified way of initializing algorest \r\n* 0.1.0 Initial release",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/algotronic/algorest/issues"
  },
  "homepage": "https://github.com/algotronic/algorest",
  "_id": "algorest@0.2.0",
  "_shasum": "d2c0722cddb9a46bcffdefd9ada745c8c251528f",
  "_resolved": "git://github.com/algotronic/algorest.git#2e4e5b24e2c06678d2d58f08a605015a07e18253",
  "_from": "algorest@git://github.com/algotronic/algorest.git#v2"
}
